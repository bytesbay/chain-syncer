// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@/types
//   ../ethers

declare module 'chain-syncer' {
    import { ChainSyncer } from 'chain-syncer/lib/chain-syncer';
    import { InMemoryAdapter } from 'chain-syncer/lib/in-memory-adapter';
    export default ChainSyncer;
    export { ChainSyncer, InMemoryAdapter };
    export * from 'chain-syncer/types';
}

declare module 'chain-syncer/lib/chain-syncer' {
    import { IChainSyncerAdapter, TChainSyncerContractsGetterHook, IChainSyncerLogger, IChainSyncerOptions, IChainSyncerListener, IChainSyncerSubscriber } from "@/types";
    import { ethers as Ethers } from "ethers";
    import { _loadUsedBlocks, _loadUsedTxs, _parseEventId, _parseListenerName, _uniq } from "chain-syncer/lib/chain-syncer/helpers";
    export class ChainSyncer {
        listeners: Record<string, IChainSyncerListener>;
        used_contracts: string[];
        subscribers: IChainSyncerSubscriber[];
        _next_safe_at: number;
        _is_started: boolean;
        _is_scanner_busy: boolean;
        _is_processor_busy: boolean;
        _current_max_block: number;
        addEvents: (this: ChainSyncer, scans: import("@/types").IChainSyncerScanResult[]) => Promise<import("@/types").IChainSyncerEvent[]>;
        parseEvent: (this: ChainSyncer, contract_name: string, event: Ethers.Event, block: Ethers.providers.Block, tx: Ethers.providers.TransactionResponse) => import("@/types").IChainSyncerEvent;
        getContractEvents: (this: ChainSyncer, contract_name: string, max_block: number, opts?: import("@/types").IChainSyncerGetContractsEventsOptions) => Promise<import("@/types").IChainSyncerScanResult>;
        saveLatestBlocks: (this: ChainSyncer, scans: import("@/types").IChainSyncerScanResult[]) => Promise<void>;
        scanContracts: (this: ChainSyncer, max_block: number, opts?: import("@/types").IChainSyncerGetContractsEventsOptions) => Promise<{
            scans: import("@/types").IChainSyncerScanResult[];
            events: import("@/types").IChainSyncerEvent[];
        }>;
        scanContractBlocks: (this: ChainSyncer, contract_getter_result: import("@/types").IChainSyncerContractsGetterResult, contract_name: string, from_block: number, to_block: number) => Promise<import("@/types").IChainSyncerScanResult>;
        on: (this: ChainSyncer, event: string, listener: import("@/types").TChainSyncerListenerHook) => Promise<void>;
        updateSubscriber: (this: ChainSyncer, subscriber: string, events: string[]) => Promise<void>;
        syncSubscribers: (this: ChainSyncer) => Promise<void>;
        scannerTick: (this: ChainSyncer) => Promise<void>;
        safeRescan: (this: ChainSyncer, max_block: number) => Promise<void>;
        processingTick: (this: ChainSyncer) => Promise<void>;
        processSubscriberEvents: (this: ChainSyncer, subscriber: string) => Promise<void>;
        _uniq: typeof _uniq;
        _parseListenerName: typeof _parseListenerName;
        _parseEventId: typeof _parseEventId;
        _loadUsedBlocks: typeof _loadUsedBlocks;
        _loadUsedTxs: typeof _loadUsedTxs;
        query_block_limit: number;
        block_time: number;
        tick_interval: number;
        adapter: IChainSyncerAdapter;
        mode: string;
        ethers_provider: Ethers.providers.Provider;
        contractsGetter: TChainSyncerContractsGetterHook;
        verbose: boolean;
        safe_rescan_every_n_block: number;
        safe_rescans_to_repeat: number;
        logger: IChainSyncerLogger;
        constructor(adapter: IChainSyncerAdapter, opts: IChainSyncerOptions);
        start(): Promise<void>;
        stop(): Promise<void>;
        selectPendingEvents(subscriber: string): Promise<import("@/types").IChainSyncerEvent[]>;
        markEventsAsProcessed(subscriber: string, event_ids: string[]): Promise<void>;
    }
}

declare module 'chain-syncer/lib/in-memory-adapter' {
    import { IChainSyncerAdapter, IChainSyncerEvent, IChainSyncerSubscriber } from "@/types";
    import { IEvent } from "chain-syncer/lib/in-memory-adapter/event";
    import { IQueueEvent } from "chain-syncer/lib/in-memory-adapter/queue-event";
    interface ISubscriber {
        name: string;
        events: string[];
        added_at: Record<string, number>;
    }
    export class InMemoryAdapter implements IChainSyncerAdapter {
        latest_blocks: Record<string, number>;
        events: IEvent[];
        events_queue: IQueueEvent[];
        subscribers: Record<string, ISubscriber>;
        _is_chainsyncer_adapter: boolean;
        constructor();
        getLatestScannedBlockNumber(contract_name: string): Promise<number>;
        removeQueue(subscriber: string, events: string[]): Promise<void>;
        addUnprocessedEventsToQueue(subscriber: string, events: string[]): Promise<void>;
        selectAllSubscribers(): Promise<ISubscriber[]>;
        updateSubscriber(subscriber: string, events: string[]): Promise<{
            events_added: string[];
            events_removed: string[];
        }>;
        saveLatestScannedBlockNumber(contract_name: string, block_number: number): Promise<void>;
        selectAllUnprocessedEventsBySubscriber(subscriber: string): Promise<IEvent[]>;
        setEventProcessedForSubscriber(id: string, subscriber: string): Promise<void>;
        filterExistingEvents(ids: string[]): Promise<string[]>;
        saveEvents(_events: IChainSyncerEvent[], subscribers: IChainSyncerSubscriber[]): Promise<void>;
    }
    export {};
}

declare module 'chain-syncer/types' {
    import { ethers as Ethers } from "ethers";
    export type TChainSyncerEventArg = (number | string | boolean);
    export interface IChainSyncerEvent {
            id: string;
            contract: string;
            event: string;
            transaction_hash: string;
            block_number: number;
            log_index: number;
            tx_index: number;
            from_address: string;
            global_index: number;
            block_timestamp: number;
            args: TChainSyncerEventArg[];
    }
    export interface IChainSyncerSubscriber {
            name: string;
            events: string[];
    }
    export interface IChainSyncerAdapter {
            getLatestScannedBlockNumber(contract_name: string): Promise<number>;
            removeQueue(subscriber: string, events: string[]): Promise<void>;
            addUnprocessedEventsToQueue(subscriber: string, events: string[]): Promise<void>;
            selectAllSubscribers(): Promise<IChainSyncerSubscriber[]>;
            updateSubscriber(subscriber: string, events: string[]): Promise<{
                    events_added: string[];
                    events_removed: string[];
            }>;
            saveLatestScannedBlockNumber(contract_name: string, block_number: number): Promise<void>;
            selectAllUnprocessedEventsBySubscriber(subscriber: string): Promise<IChainSyncerEvent[]>;
            setEventProcessedForSubscriber(id: string, subscriber: string): Promise<void>;
            filterExistingEvents(ids: string[]): Promise<string[]>;
            saveEvents(events: IChainSyncerEvent[], subscribers: IChainSyncerSubscriber[]): Promise<void>;
    }
    export interface IChainSyncerContractsGetterResult {
            ethers_contract: Ethers.Contract;
            deploy_transaction_hash: string;
    }
    export type TChainSyncerContractsGetterHook = (contract_name: string, metadata: IChainSyncerContractsGetterMetadata) => Promise<IChainSyncerContractsGetterResult>;
    export interface IChainSyncerLogger {
            log(...args: any[]): void;
            error(...args: any[]): void;
            warn(...args: any[]): void;
    }
    export interface IChainSyncerOptions {
            /**
                * How many safe rescans to repeat before the current rescan
                */
            safe_rescans_to_repeat?: number;
            /**
                * Blocktime of the chain in milliseconds
                */
            block_time: number;
            /**
                *
                */
            contractsGetter: TChainSyncerContractsGetterHook;
            /**
                * EthersJS provider
                */
            ethers_provider: Ethers.providers.Provider;
            /**
                * How many blocks to query at once
                */
            query_block_limit?: number;
            /**
                * Procissing loop interval
                */
            tick_interval?: number;
            /**
                *
                */
            mode?: 'mono' | 'scanner';
            /**
                *
                */
            verbose?: boolean;
            /**
                *
                */
            safe_rescan_every_n_block?: number;
            contracts?: string[];
            logger?: IChainSyncerLogger;
    }
    export interface IChainSyncerScanResult {
            contract_name: string;
            events: Ethers.Event[];
            block: number;
    }
    export interface IChainSyncerContractsGetterMetadata {
            max_block: number;
            from_block: number;
            to_block: number;
            archive_rpc_advised: boolean;
            for_genesis_tx_lookup: boolean;
    }
    export interface IChainSyncerEventMetadata {
            from_address: string;
            block_timestamp: number;
            block_number: number;
            transaction_hash: string;
            global_index: number;
    }
    export interface IChainSyncerGetContractsEventsOptions {
            force_rescan_till?: number;
    }
    export type TChainSyncerListenerHook = (metadata: IChainSyncerEventMetadata, ...args: TChainSyncerEventArg[]) => Promise<void | boolean> | (void | boolean);
    export interface IChainSyncerListener {
            full_event: string;
            listener: TChainSyncerListenerHook;
            contract_name: string;
            event_name: string;
    }
}

declare module 'chain-syncer/lib/chain-syncer/helpers' {
    import { ethers as Ethers } from "ethers";
    import { ChainSyncer } from "chain-syncer/lib/chain-syncer";
    export function _uniq<T extends (string | number)>(a: T[]): T[];
    export function _parseListenerName(this: ChainSyncer, event: string): {
        contract_name: string;
        event_name: string;
    };
    export function _parseEventId(this: ChainSyncer, event: Ethers.Event): string;
    export function _loadUsedBlocks(this: ChainSyncer, events: Ethers.Event[]): Promise<Ethers.providers.Block[]>;
    export function _loadUsedTxs(this: ChainSyncer, events: Ethers.Event[]): Promise<Ethers.providers.TransactionResponse[]>;
}

declare module 'chain-syncer/lib/in-memory-adapter/event' {
    import { IChainSyncerEvent } from "@/types";
    export function toEvent(data: IChainSyncerEvent): IEvent;
    export interface IEvent extends IChainSyncerEvent {
        processed_subscribers: any;
    }
}

declare module 'chain-syncer/lib/in-memory-adapter/queue-event' {
    import { IEvent } from "chain-syncer/lib/in-memory-adapter/event";
    export function toQueueEvent(event: IEvent, subscriber: string): IQueueEvent;
    export interface IQueueEvent {
        id: string;
        event_id: string;
        event: string;
        contract: string;
        subscriber: string;
    }
}

